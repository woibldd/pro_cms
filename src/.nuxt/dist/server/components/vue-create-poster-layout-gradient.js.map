{"version":3,"file":"components/vue-create-poster-layout-gradient.js","sources":["webpack:///./components/vue-create-poster/layout/gradient.js"],"sourcesContent":["/* eslint-disable */\r\nexport const api = {\r\n  isGradient: function(bg) {\r\n    if (bg && (bg.startsWith('linear') || bg.startsWith('radial'))) {\r\n      return true\r\n    }\r\n    return false\r\n  },\r\n\r\n  doGradient: function(bg, width, height, ctx) {\r\n    if (bg.startsWith('linear')) {\r\n      linearEffect(width, height, bg, ctx)\r\n    } else if (bg.startsWith('radial')) {\r\n      radialEffect(width, height, bg, ctx)\r\n    }\r\n  }\r\n}\r\n\r\nfunction analizeGrad(string) {\r\n  const colorPercents = string.substring(0, string.length - 1).split('%,')\r\n  const colors = []\r\n  const percents = []\r\n  for (let colorPercent of colorPercents) {\r\n    colors.push(colorPercent.substring(0, colorPercent.lastIndexOf(' ')).trim())\r\n    percents.push(colorPercent.substring(colorPercent.lastIndexOf(' '), colorPercent.length) / 100)\r\n  }\r\n  return { colors: colors, percents: percents }\r\n}\r\n\r\nfunction radialEffect(width, height, bg, ctx) {\r\n  const colorPer = analizeGrad(bg.match(/radial-gradient\\((.+)\\)/)[1])\r\n  const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, width < height ? height / 2 : width / 2)\r\n  for (let i = 0; i < colorPer.colors.length; i++) {\r\n    grd.addColorStop(colorPer.percents[i], colorPer.colors[i])\r\n  }\r\n  ctx.fillStyle = grd\r\n  //ctx.fillRect(-(width / 2), -(height / 2), width, height);\r\n}\r\n\r\nfunction analizeLinear(bg, width, height) {\r\n  const direction = bg.match(/([-]?\\d{1,3})deg/)\r\n  const dir = direction && direction[1] ? parseFloat(direction[1]) : 0\r\n  let coordinate\r\n  switch (dir) {\r\n    case 0:\r\n      coordinate = [0, -height / 2, 0, height / 2]\r\n      break\r\n    case 90:\r\n      coordinate = [width / 2, 0, -width / 2, 0]\r\n      break\r\n    case -90:\r\n      coordinate = [-width / 2, 0, width / 2, 0]\r\n      break\r\n    case 180:\r\n      coordinate = [0, height / 2, 0, -height / 2]\r\n      break\r\n    case -180:\r\n      coordinate = [0, -height / 2, 0, height / 2]\r\n      break\r\n    default:\r\n      let x1 = 0\r\n      let y1 = 0\r\n      let x2 = 0\r\n      let y2 = 0\r\n      if (direction[1] > 0 && direction[1] < 90) {\r\n        x1 = width / 2 - (((width / 2) * Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) - height / 2) * Math.sin((2 * (90 - direction[1]) * Math.PI * 2) / 360)) / 2\r\n        y2 = Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) * x1\r\n        x2 = -x1\r\n        y1 = -y2\r\n      } else if (direction[1] > -180 && direction[1] < -90) {\r\n        x1 = -(width / 2) + (((width / 2) * Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) - height / 2) * Math.sin((2 * (90 - direction[1]) * Math.PI * 2) / 360)) / 2\r\n        y2 = Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) * x1\r\n        x2 = -x1\r\n        y1 = -y2\r\n      } else if (direction[1] > 90 && direction[1] < 180) {\r\n        x1 = width / 2 + ((-(width / 2) * Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) - height / 2) * Math.sin((2 * (90 - direction[1]) * Math.PI * 2) / 360)) / 2\r\n        y2 = Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) * x1\r\n        x2 = -x1\r\n        y1 = -y2\r\n      } else {\r\n        x1 = -(width / 2) - ((-(width / 2) * Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) - height / 2) * Math.sin((2 * (90 - direction[1]) * Math.PI * 2) / 360)) / 2\r\n        y2 = Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) * x1\r\n        x2 = -x1\r\n        y1 = -y2\r\n      }\r\n      coordinate = [x1, y1, x2, y2]\r\n      break\r\n  }\r\n  return coordinate\r\n}\r\n\r\nfunction linearEffect(width, height, bg, ctx) {\r\n  const param = analizeLinear(bg, width, height)\r\n  const grd = ctx.createLinearGradient(param[0], param[1], param[2], param[3])\r\n  const content = bg.match(/linear-gradient\\((.+)\\)/)[1]\r\n  const colorPer = analizeGrad(content.substring(content.indexOf(',') + 1))\r\n  for (let i = 0; i < colorPer.colors.length; i++) {\r\n    grd.addColorStop(colorPer.percents[i], colorPer.colors[i])\r\n  }\r\n  ctx.fillStyle = grd\r\n  //ctx.fillRect(-(width / 2), -(height / 2), width, height);\r\n}\r\n"],"mappings":";;;;;;;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AACA;AAgBA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AA3CA;AACA;AA4CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;;;;A","sourceRoot":""}