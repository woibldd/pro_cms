{"version":3,"file":"components/vue-create-poster-layout.js","sources":["webpack:///./components/vue-create-poster/layout/qrcode.js","webpack:///./components/vue-create-poster/layout/gradient.js","webpack:///./components/vue-create-poster/layout/canvas-poster.vue?9406","webpack:///./components/vue-create-poster/layout/painter.js","webpack:///./components/vue-create-poster/layout/util.js","webpack:///./components/vue-create-poster/layout/canvas-poster.vue?71c5","webpack:///./components/vue-create-poster/layout/canvas-poster.vue","webpack:///./components/vue-create-poster/layout/canvas-poster.vue?3a05","webpack:///./components/vue-create-poster/layout/canvas-poster.vue?5c29","webpack:///./components/vue-create-poster/layout/index.js"],"sourcesContent":["/* eslint-disable */\r\n\r\n  // alignment pattern\r\n  var adelta = [\r\n    0, 11, 15, 19, 23, 27, 31,\r\n    16, 18, 20, 22, 24, 26, 28, 20, 22, 24, 24, 26, 28, 28, 22, 24, 24,\r\n    26, 26, 28, 28, 24, 24, 26, 26, 26, 28, 28, 24, 26, 26, 26, 28, 28\r\n  ];\r\n\r\n  // version block\r\n  var vpat = [\r\n    0xc94, 0x5bc, 0xa99, 0x4d3, 0xbf6, 0x762, 0x847, 0x60d,\r\n    0x928, 0xb78, 0x45d, 0xa17, 0x532, 0x9a6, 0x683, 0x8c9,\r\n    0x7ec, 0xec4, 0x1e1, 0xfab, 0x08e, 0xc1a, 0x33f, 0xd75,\r\n    0x250, 0x9d5, 0x6f0, 0x8ba, 0x79f, 0xb0b, 0x42e, 0xa64,\r\n    0x541, 0xc69\r\n  ];\r\n\r\n  // final format bits with mask: level << 3 | mask\r\n  var fmtword = [\r\n    0x77c4, 0x72f3, 0x7daa, 0x789d, 0x662f, 0x6318, 0x6c41, 0x6976,    //L\r\n    0x5412, 0x5125, 0x5e7c, 0x5b4b, 0x45f9, 0x40ce, 0x4f97, 0x4aa0,    //M\r\n    0x355f, 0x3068, 0x3f31, 0x3a06, 0x24b4, 0x2183, 0x2eda, 0x2bed,    //Q\r\n    0x1689, 0x13be, 0x1ce7, 0x19d0, 0x0762, 0x0255, 0x0d0c, 0x083b    //H\r\n  ];\r\n\r\n  // 4 per version: number of blocks 1,2; data width; ecc width\r\n  var eccblocks = [\r\n    1, 0, 19, 7, 1, 0, 16, 10, 1, 0, 13, 13, 1, 0, 9, 17,\r\n    1, 0, 34, 10, 1, 0, 28, 16, 1, 0, 22, 22, 1, 0, 16, 28,\r\n    1, 0, 55, 15, 1, 0, 44, 26, 2, 0, 17, 18, 2, 0, 13, 22,\r\n    1, 0, 80, 20, 2, 0, 32, 18, 2, 0, 24, 26, 4, 0, 9, 16,\r\n    1, 0, 108, 26, 2, 0, 43, 24, 2, 2, 15, 18, 2, 2, 11, 22,\r\n    2, 0, 68, 18, 4, 0, 27, 16, 4, 0, 19, 24, 4, 0, 15, 28,\r\n    2, 0, 78, 20, 4, 0, 31, 18, 2, 4, 14, 18, 4, 1, 13, 26,\r\n    2, 0, 97, 24, 2, 2, 38, 22, 4, 2, 18, 22, 4, 2, 14, 26,\r\n    2, 0, 116, 30, 3, 2, 36, 22, 4, 4, 16, 20, 4, 4, 12, 24,\r\n    2, 2, 68, 18, 4, 1, 43, 26, 6, 2, 19, 24, 6, 2, 15, 28,\r\n    4, 0, 81, 20, 1, 4, 50, 30, 4, 4, 22, 28, 3, 8, 12, 24,\r\n    2, 2, 92, 24, 6, 2, 36, 22, 4, 6, 20, 26, 7, 4, 14, 28,\r\n    4, 0, 107, 26, 8, 1, 37, 22, 8, 4, 20, 24, 12, 4, 11, 22,\r\n    3, 1, 115, 30, 4, 5, 40, 24, 11, 5, 16, 20, 11, 5, 12, 24,\r\n    5, 1, 87, 22, 5, 5, 41, 24, 5, 7, 24, 30, 11, 7, 12, 24,\r\n    5, 1, 98, 24, 7, 3, 45, 28, 15, 2, 19, 24, 3, 13, 15, 30,\r\n    1, 5, 107, 28, 10, 1, 46, 28, 1, 15, 22, 28, 2, 17, 14, 28,\r\n    5, 1, 120, 30, 9, 4, 43, 26, 17, 1, 22, 28, 2, 19, 14, 28,\r\n    3, 4, 113, 28, 3, 11, 44, 26, 17, 4, 21, 26, 9, 16, 13, 26,\r\n    3, 5, 107, 28, 3, 13, 41, 26, 15, 5, 24, 30, 15, 10, 15, 28,\r\n    4, 4, 116, 28, 17, 0, 42, 26, 17, 6, 22, 28, 19, 6, 16, 30,\r\n    2, 7, 111, 28, 17, 0, 46, 28, 7, 16, 24, 30, 34, 0, 13, 24,\r\n    4, 5, 121, 30, 4, 14, 47, 28, 11, 14, 24, 30, 16, 14, 15, 30,\r\n    6, 4, 117, 30, 6, 14, 45, 28, 11, 16, 24, 30, 30, 2, 16, 30,\r\n    8, 4, 106, 26, 8, 13, 47, 28, 7, 22, 24, 30, 22, 13, 15, 30,\r\n    10, 2, 114, 28, 19, 4, 46, 28, 28, 6, 22, 28, 33, 4, 16, 30,\r\n    8, 4, 122, 30, 22, 3, 45, 28, 8, 26, 23, 30, 12, 28, 15, 30,\r\n    3, 10, 117, 30, 3, 23, 45, 28, 4, 31, 24, 30, 11, 31, 15, 30,\r\n    7, 7, 116, 30, 21, 7, 45, 28, 1, 37, 23, 30, 19, 26, 15, 30,\r\n    5, 10, 115, 30, 19, 10, 47, 28, 15, 25, 24, 30, 23, 25, 15, 30,\r\n    13, 3, 115, 30, 2, 29, 46, 28, 42, 1, 24, 30, 23, 28, 15, 30,\r\n    17, 0, 115, 30, 10, 23, 46, 28, 10, 35, 24, 30, 19, 35, 15, 30,\r\n    17, 1, 115, 30, 14, 21, 46, 28, 29, 19, 24, 30, 11, 46, 15, 30,\r\n    13, 6, 115, 30, 14, 23, 46, 28, 44, 7, 24, 30, 59, 1, 16, 30,\r\n    12, 7, 121, 30, 12, 26, 47, 28, 39, 14, 24, 30, 22, 41, 15, 30,\r\n    6, 14, 121, 30, 6, 34, 47, 28, 46, 10, 24, 30, 2, 64, 15, 30,\r\n    17, 4, 122, 30, 29, 14, 46, 28, 49, 10, 24, 30, 24, 46, 15, 30,\r\n    4, 18, 122, 30, 13, 32, 46, 28, 48, 14, 24, 30, 42, 32, 15, 30,\r\n    20, 4, 117, 30, 40, 7, 47, 28, 43, 22, 24, 30, 10, 67, 15, 30,\r\n    19, 6, 118, 30, 18, 31, 47, 28, 34, 34, 24, 30, 20, 61, 15, 30\r\n  ];\r\n\r\n  // Galois field log table\r\n  var glog = [\r\n    0xff, 0x00, 0x01, 0x19, 0x02, 0x32, 0x1a, 0xc6, 0x03, 0xdf, 0x33, 0xee, 0x1b, 0x68, 0xc7, 0x4b,\r\n    0x04, 0x64, 0xe0, 0x0e, 0x34, 0x8d, 0xef, 0x81, 0x1c, 0xc1, 0x69, 0xf8, 0xc8, 0x08, 0x4c, 0x71,\r\n    0x05, 0x8a, 0x65, 0x2f, 0xe1, 0x24, 0x0f, 0x21, 0x35, 0x93, 0x8e, 0xda, 0xf0, 0x12, 0x82, 0x45,\r\n    0x1d, 0xb5, 0xc2, 0x7d, 0x6a, 0x27, 0xf9, 0xb9, 0xc9, 0x9a, 0x09, 0x78, 0x4d, 0xe4, 0x72, 0xa6,\r\n    0x06, 0xbf, 0x8b, 0x62, 0x66, 0xdd, 0x30, 0xfd, 0xe2, 0x98, 0x25, 0xb3, 0x10, 0x91, 0x22, 0x88,\r\n    0x36, 0xd0, 0x94, 0xce, 0x8f, 0x96, 0xdb, 0xbd, 0xf1, 0xd2, 0x13, 0x5c, 0x83, 0x38, 0x46, 0x40,\r\n    0x1e, 0x42, 0xb6, 0xa3, 0xc3, 0x48, 0x7e, 0x6e, 0x6b, 0x3a, 0x28, 0x54, 0xfa, 0x85, 0xba, 0x3d,\r\n    0xca, 0x5e, 0x9b, 0x9f, 0x0a, 0x15, 0x79, 0x2b, 0x4e, 0xd4, 0xe5, 0xac, 0x73, 0xf3, 0xa7, 0x57,\r\n    0x07, 0x70, 0xc0, 0xf7, 0x8c, 0x80, 0x63, 0x0d, 0x67, 0x4a, 0xde, 0xed, 0x31, 0xc5, 0xfe, 0x18,\r\n    0xe3, 0xa5, 0x99, 0x77, 0x26, 0xb8, 0xb4, 0x7c, 0x11, 0x44, 0x92, 0xd9, 0x23, 0x20, 0x89, 0x2e,\r\n    0x37, 0x3f, 0xd1, 0x5b, 0x95, 0xbc, 0xcf, 0xcd, 0x90, 0x87, 0x97, 0xb2, 0xdc, 0xfc, 0xbe, 0x61,\r\n    0xf2, 0x56, 0xd3, 0xab, 0x14, 0x2a, 0x5d, 0x9e, 0x84, 0x3c, 0x39, 0x53, 0x47, 0x6d, 0x41, 0xa2,\r\n    0x1f, 0x2d, 0x43, 0xd8, 0xb7, 0x7b, 0xa4, 0x76, 0xc4, 0x17, 0x49, 0xec, 0x7f, 0x0c, 0x6f, 0xf6,\r\n    0x6c, 0xa1, 0x3b, 0x52, 0x29, 0x9d, 0x55, 0xaa, 0xfb, 0x60, 0x86, 0xb1, 0xbb, 0xcc, 0x3e, 0x5a,\r\n    0xcb, 0x59, 0x5f, 0xb0, 0x9c, 0xa9, 0xa0, 0x51, 0x0b, 0xf5, 0x16, 0xeb, 0x7a, 0x75, 0x2c, 0xd7,\r\n    0x4f, 0xae, 0xd5, 0xe9, 0xe6, 0xe7, 0xad, 0xe8, 0x74, 0xd6, 0xf4, 0xea, 0xa8, 0x50, 0x58, 0xaf\r\n  ];\r\n\r\n  // Galios field exponent table\r\n  var gexp = [\r\n    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1d, 0x3a, 0x74, 0xe8, 0xcd, 0x87, 0x13, 0x26,\r\n    0x4c, 0x98, 0x2d, 0x5a, 0xb4, 0x75, 0xea, 0xc9, 0x8f, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0,\r\n    0x9d, 0x27, 0x4e, 0x9c, 0x25, 0x4a, 0x94, 0x35, 0x6a, 0xd4, 0xb5, 0x77, 0xee, 0xc1, 0x9f, 0x23,\r\n    0x46, 0x8c, 0x05, 0x0a, 0x14, 0x28, 0x50, 0xa0, 0x5d, 0xba, 0x69, 0xd2, 0xb9, 0x6f, 0xde, 0xa1,\r\n    0x5f, 0xbe, 0x61, 0xc2, 0x99, 0x2f, 0x5e, 0xbc, 0x65, 0xca, 0x89, 0x0f, 0x1e, 0x3c, 0x78, 0xf0,\r\n    0xfd, 0xe7, 0xd3, 0xbb, 0x6b, 0xd6, 0xb1, 0x7f, 0xfe, 0xe1, 0xdf, 0xa3, 0x5b, 0xb6, 0x71, 0xe2,\r\n    0xd9, 0xaf, 0x43, 0x86, 0x11, 0x22, 0x44, 0x88, 0x0d, 0x1a, 0x34, 0x68, 0xd0, 0xbd, 0x67, 0xce,\r\n    0x81, 0x1f, 0x3e, 0x7c, 0xf8, 0xed, 0xc7, 0x93, 0x3b, 0x76, 0xec, 0xc5, 0x97, 0x33, 0x66, 0xcc,\r\n    0x85, 0x17, 0x2e, 0x5c, 0xb8, 0x6d, 0xda, 0xa9, 0x4f, 0x9e, 0x21, 0x42, 0x84, 0x15, 0x2a, 0x54,\r\n    0xa8, 0x4d, 0x9a, 0x29, 0x52, 0xa4, 0x55, 0xaa, 0x49, 0x92, 0x39, 0x72, 0xe4, 0xd5, 0xb7, 0x73,\r\n    0xe6, 0xd1, 0xbf, 0x63, 0xc6, 0x91, 0x3f, 0x7e, 0xfc, 0xe5, 0xd7, 0xb3, 0x7b, 0xf6, 0xf1, 0xff,\r\n    0xe3, 0xdb, 0xab, 0x4b, 0x96, 0x31, 0x62, 0xc4, 0x95, 0x37, 0x6e, 0xdc, 0xa5, 0x57, 0xae, 0x41,\r\n    0x82, 0x19, 0x32, 0x64, 0xc8, 0x8d, 0x07, 0x0e, 0x1c, 0x38, 0x70, 0xe0, 0xdd, 0xa7, 0x53, 0xa6,\r\n    0x51, 0xa2, 0x59, 0xb2, 0x79, 0xf2, 0xf9, 0xef, 0xc3, 0x9b, 0x2b, 0x56, 0xac, 0x45, 0x8a, 0x09,\r\n    0x12, 0x24, 0x48, 0x90, 0x3d, 0x7a, 0xf4, 0xf5, 0xf7, 0xf3, 0xfb, 0xeb, 0xcb, 0x8b, 0x0b, 0x16,\r\n    0x2c, 0x58, 0xb0, 0x7d, 0xfa, 0xe9, 0xcf, 0x83, 0x1b, 0x36, 0x6c, 0xd8, 0xad, 0x47, 0x8e, 0x00\r\n  ];\r\n\r\n  // Working buffers:\r\n  // data input and ecc append, image working buffer, fixed part of image, run lengths for badness\r\n  var strinbuf = [], eccbuf = [], qrframe = [], framask = [], rlens = [];\r\n  // Control values - width is based on version, last 4 are from table.\r\n  var version, width, neccblk1, neccblk2, datablkw, eccblkwid;\r\n  var ecclevel = 2;\r\n  // set bit to indicate cell in qrframe is immutable.  symmetric around diagonal\r\n  function setmask(x, y) {\r\n    var bt;\r\n    if (x > y) {\r\n      bt = x;\r\n      x = y;\r\n      y = bt;\r\n    }\r\n    // y*y = 1+3+5...\r\n    bt = y;\r\n    bt *= y;\r\n    bt += y;\r\n    bt >>= 1;\r\n    bt += x;\r\n    framask[bt] = 1;\r\n  }\r\n\r\n  // enter alignment pattern - black to qrframe, white to mask (later black frame merged to mask)\r\n  function putalign(x, y) {\r\n    var j;\r\n\r\n    qrframe[x + width * y] = 1;\r\n    for (j = -2; j < 2; j++) {\r\n      qrframe[(x + j) + width * (y - 2)] = 1;\r\n      qrframe[(x - 2) + width * (y + j + 1)] = 1;\r\n      qrframe[(x + 2) + width * (y + j)] = 1;\r\n      qrframe[(x + j + 1) + width * (y + 2)] = 1;\r\n    }\r\n    for (j = 0; j < 2; j++) {\r\n      setmask(x - 1, y + j);\r\n      setmask(x + 1, y - j);\r\n      setmask(x - j, y - 1);\r\n      setmask(x + j, y + 1);\r\n    }\r\n  }\r\n\r\n  //========================================================================\r\n  // Reed Solomon error correction\r\n  // exponentiation mod N\r\n  function modnn(x) {\r\n    while (x >= 255) {\r\n      x -= 255;\r\n      x = (x >> 8) + (x & 255);\r\n    }\r\n    return x;\r\n  }\r\n\r\n  var genpoly = [];\r\n\r\n  // Calculate and append ECC data to data block.  Block is in strinbuf, indexes to buffers given.\r\n  function appendrs(data, dlen, ecbuf, eclen) {\r\n    var i, j, fb;\r\n\r\n    for (i = 0; i < eclen; i++)\r\n      strinbuf[ecbuf + i] = 0;\r\n    for (i = 0; i < dlen; i++) {\r\n      fb = glog[strinbuf[data + i] ^ strinbuf[ecbuf]];\r\n      if (fb != 255)     /* fb term is non-zero */\r\n        for (j = 1; j < eclen; j++)\r\n          strinbuf[ecbuf + j - 1] = strinbuf[ecbuf + j] ^ gexp[modnn(fb + genpoly[eclen - j])];\r\n      else\r\n        for (j = ecbuf; j < ecbuf + eclen; j++)\r\n          strinbuf[j] = strinbuf[j + 1];\r\n      strinbuf[ecbuf + eclen - 1] = fb == 255 ? 0 : gexp[modnn(fb + genpoly[0])];\r\n    }\r\n  }\r\n\r\n  //========================================================================\r\n  // Frame data insert following the path rules\r\n\r\n  // check mask - since symmetrical use half.\r\n  function ismasked(x, y) {\r\n    var bt;\r\n    if (x > y) {\r\n      bt = x;\r\n      x = y;\r\n      y = bt;\r\n    }\r\n    bt = y;\r\n    bt += y * y;\r\n    bt >>= 1;\r\n    bt += x;\r\n    return framask[bt];\r\n  }\r\n\r\n  //========================================================================\r\n  //  Apply the selected mask out of the 8.\r\n  function applymask(m) {\r\n    var x, y, r3x, r3y;\r\n\r\n    switch (m) {\r\n      case 0:\r\n        for (y = 0; y < width; y++)\r\n          for (x = 0; x < width; x++)\r\n            if (!((x + y) & 1) && !ismasked(x, y))\r\n              qrframe[x + y * width] ^= 1;\r\n        break;\r\n      case 1:\r\n        for (y = 0; y < width; y++)\r\n          for (x = 0; x < width; x++)\r\n            if (!(y & 1) && !ismasked(x, y))\r\n              qrframe[x + y * width] ^= 1;\r\n        break;\r\n      case 2:\r\n        for (y = 0; y < width; y++)\r\n          for (r3x = 0, x = 0; x < width; x++ , r3x++) {\r\n            if (r3x == 3)\r\n              r3x = 0;\r\n            if (!r3x && !ismasked(x, y))\r\n              qrframe[x + y * width] ^= 1;\r\n          }\r\n        break;\r\n      case 3:\r\n        for (r3y = 0, y = 0; y < width; y++ , r3y++) {\r\n          if (r3y == 3)\r\n            r3y = 0;\r\n          for (r3x = r3y, x = 0; x < width; x++ , r3x++) {\r\n            if (r3x == 3)\r\n              r3x = 0;\r\n            if (!r3x && !ismasked(x, y))\r\n              qrframe[x + y * width] ^= 1;\r\n          }\r\n        }\r\n        break;\r\n      case 4:\r\n        for (y = 0; y < width; y++)\r\n          for (r3x = 0, r3y = ((y >> 1) & 1), x = 0; x < width; x++ , r3x++) {\r\n            if (r3x == 3) {\r\n              r3x = 0;\r\n              r3y = !r3y;\r\n            }\r\n            if (!r3y && !ismasked(x, y))\r\n              qrframe[x + y * width] ^= 1;\r\n          }\r\n        break;\r\n      case 5:\r\n        for (r3y = 0, y = 0; y < width; y++ , r3y++) {\r\n          if (r3y == 3)\r\n            r3y = 0;\r\n          for (r3x = 0, x = 0; x < width; x++ , r3x++) {\r\n            if (r3x == 3)\r\n              r3x = 0;\r\n            if (!((x & y & 1) + !(!r3x | !r3y)) && !ismasked(x, y))\r\n              qrframe[x + y * width] ^= 1;\r\n          }\r\n        }\r\n        break;\r\n      case 6:\r\n        for (r3y = 0, y = 0; y < width; y++ , r3y++) {\r\n          if (r3y == 3)\r\n            r3y = 0;\r\n          for (r3x = 0, x = 0; x < width; x++ , r3x++) {\r\n            if (r3x == 3)\r\n              r3x = 0;\r\n            if (!(((x & y & 1) + (r3x && (r3x == r3y))) & 1) && !ismasked(x, y))\r\n              qrframe[x + y * width] ^= 1;\r\n          }\r\n        }\r\n        break;\r\n      case 7:\r\n        for (r3y = 0, y = 0; y < width; y++ , r3y++) {\r\n          if (r3y == 3)\r\n            r3y = 0;\r\n          for (r3x = 0, x = 0; x < width; x++ , r3x++) {\r\n            if (r3x == 3)\r\n              r3x = 0;\r\n            if (!(((r3x && (r3x == r3y)) + ((x + y) & 1)) & 1) && !ismasked(x, y))\r\n              qrframe[x + y * width] ^= 1;\r\n          }\r\n        }\r\n        break;\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Badness coefficients.\r\n  var N1 = 3, N2 = 3, N3 = 40, N4 = 10;\r\n\r\n  // Using the table of the length of each run, calculate the amount of bad image \r\n  // - long runs or those that look like finders; called twice, once each for X and Y\r\n  function badruns(length) {\r\n    var i;\r\n    var runsbad = 0;\r\n    for (i = 0; i <= length; i++)\r\n      if (rlens[i] >= 5)\r\n        runsbad += N1 + rlens[i] - 5;\r\n    // BwBBBwB as in finder\r\n    for (i = 3; i < length - 1; i += 2)\r\n      if (rlens[i - 2] == rlens[i + 2]\r\n        && rlens[i + 2] == rlens[i - 1]\r\n        && rlens[i - 1] == rlens[i + 1]\r\n        && rlens[i - 1] * 3 == rlens[i]\r\n        // white around the black pattern? Not part of spec\r\n        && (rlens[i - 3] == 0 // beginning\r\n          || i + 3 > length  // end\r\n          || rlens[i - 3] * 3 >= rlens[i] * 4 || rlens[i + 3] * 3 >= rlens[i] * 4)\r\n      )\r\n        runsbad += N3;\r\n    return runsbad;\r\n  }\r\n\r\n  // Calculate how bad the masked image is - blocks, imbalance, runs, or finders.\r\n  function badcheck() {\r\n    var x, y, h, b, b1;\r\n    var thisbad = 0;\r\n    var bw = 0;\r\n\r\n    // blocks of same color.\r\n    for (y = 0; y < width - 1; y++)\r\n      for (x = 0; x < width - 1; x++)\r\n        if ((qrframe[x + width * y] && qrframe[(x + 1) + width * y]\r\n          && qrframe[x + width * (y + 1)] && qrframe[(x + 1) + width * (y + 1)]) // all black\r\n          || !(qrframe[x + width * y] || qrframe[(x + 1) + width * y]\r\n            || qrframe[x + width * (y + 1)] || qrframe[(x + 1) + width * (y + 1)])) // all white\r\n          thisbad += N2;\r\n\r\n    // X runs\r\n    for (y = 0; y < width; y++) {\r\n      rlens[0] = 0;\r\n      for (h = b = x = 0; x < width; x++) {\r\n        if ((b1 = qrframe[x + width * y]) == b)\r\n          rlens[h]++;\r\n        else\r\n          rlens[++h] = 1;\r\n        b = b1;\r\n        bw += b ? 1 : -1;\r\n      }\r\n      thisbad += badruns(h);\r\n    }\r\n\r\n    // black/white imbalance\r\n    if (bw < 0)\r\n      bw = -bw;\r\n\r\n    var big = bw;\r\n    var count = 0;\r\n    big += big << 2;\r\n    big <<= 1;\r\n    while (big > width * width)\r\n      big -= width * width, count++;\r\n    thisbad += count * N4;\r\n\r\n    // Y runs\r\n    for (x = 0; x < width; x++) {\r\n      rlens[0] = 0;\r\n      for (h = b = y = 0; y < width; y++) {\r\n        if ((b1 = qrframe[x + width * y]) == b)\r\n          rlens[h]++;\r\n        else\r\n          rlens[++h] = 1;\r\n        b = b1;\r\n      }\r\n      thisbad += badruns(h);\r\n    }\r\n    return thisbad;\r\n  }\r\n\r\n  function genframe(instring) {\r\n    var x, y, k, t, v, i, j, m;\r\n\r\n    // find the smallest version that fits the string\r\n    t = instring.length;\r\n    version = 0;\r\n    do {\r\n      version++;\r\n      k = (ecclevel - 1) * 4 + (version - 1) * 16;\r\n      neccblk1 = eccblocks[k++];\r\n      neccblk2 = eccblocks[k++];\r\n      datablkw = eccblocks[k++];\r\n      eccblkwid = eccblocks[k];\r\n      k = datablkw * (neccblk1 + neccblk2) + neccblk2 - 3 + (version <= 9);\r\n      if (t <= k)\r\n        break;\r\n    } while (version < 40);\r\n\r\n    // FIXME - insure that it fits insted of being truncated\r\n    width = 17 + 4 * version;\r\n\r\n    // allocate, clear and setup data structures\r\n    v = datablkw + (datablkw + eccblkwid) * (neccblk1 + neccblk2) + neccblk2;\r\n    for (t = 0; t < v; t++)\r\n      eccbuf[t] = 0;\r\n    strinbuf = instring.slice(0);\r\n\r\n    for (t = 0; t < width * width; t++)\r\n      qrframe[t] = 0;\r\n\r\n    for (t = 0; t < (width * (width + 1) + 1) / 2; t++)\r\n      framask[t] = 0;\r\n\r\n    // insert finders - black to frame, white to mask\r\n    for (t = 0; t < 3; t++) {\r\n      k = 0;\r\n      y = 0;\r\n      if (t == 1)\r\n        k = (width - 7);\r\n      if (t == 2)\r\n        y = (width - 7);\r\n      qrframe[(y + 3) + width * (k + 3)] = 1;\r\n      for (x = 0; x < 6; x++) {\r\n        qrframe[(y + x) + width * k] = 1;\r\n        qrframe[y + width * (k + x + 1)] = 1;\r\n        qrframe[(y + 6) + width * (k + x)] = 1;\r\n        qrframe[(y + x + 1) + width * (k + 6)] = 1;\r\n      }\r\n      for (x = 1; x < 5; x++) {\r\n        setmask(y + x, k + 1);\r\n        setmask(y + 1, k + x + 1);\r\n        setmask(y + 5, k + x);\r\n        setmask(y + x + 1, k + 5);\r\n      }\r\n      for (x = 2; x < 4; x++) {\r\n        qrframe[(y + x) + width * (k + 2)] = 1;\r\n        qrframe[(y + 2) + width * (k + x + 1)] = 1;\r\n        qrframe[(y + 4) + width * (k + x)] = 1;\r\n        qrframe[(y + x + 1) + width * (k + 4)] = 1;\r\n      }\r\n    }\r\n\r\n    // alignment blocks\r\n    if (version > 1) {\r\n      t = adelta[version];\r\n      y = width - 7;\r\n      for (; ;) {\r\n        x = width - 7;\r\n        while (x > t - 3) {\r\n          putalign(x, y);\r\n          if (x < t)\r\n            break;\r\n          x -= t;\r\n        }\r\n        if (y <= t + 9)\r\n          break;\r\n        y -= t;\r\n        putalign(6, y);\r\n        putalign(y, 6);\r\n      }\r\n    }\r\n\r\n    // single black\r\n    qrframe[8 + width * (width - 8)] = 1;\r\n\r\n    // timing gap - mask only\r\n    for (y = 0; y < 7; y++) {\r\n      setmask(7, y);\r\n      setmask(width - 8, y);\r\n      setmask(7, y + width - 7);\r\n    }\r\n    for (x = 0; x < 8; x++) {\r\n      setmask(x, 7);\r\n      setmask(x + width - 8, 7);\r\n      setmask(x, width - 8);\r\n    }\r\n\r\n    // reserve mask-format area\r\n    for (x = 0; x < 9; x++)\r\n      setmask(x, 8);\r\n    for (x = 0; x < 8; x++) {\r\n      setmask(x + width - 8, 8);\r\n      setmask(8, x);\r\n    }\r\n    for (y = 0; y < 7; y++)\r\n      setmask(8, y + width - 7);\r\n\r\n    // timing row/col\r\n    for (x = 0; x < width - 14; x++)\r\n      if (x & 1) {\r\n        setmask(8 + x, 6);\r\n        setmask(6, 8 + x);\r\n      }\r\n      else {\r\n        qrframe[(8 + x) + width * 6] = 1;\r\n        qrframe[6 + width * (8 + x)] = 1;\r\n      }\r\n\r\n    // version block\r\n    if (version > 6) {\r\n      t = vpat[version - 7];\r\n      k = 17;\r\n      for (x = 0; x < 6; x++)\r\n        for (y = 0; y < 3; y++ , k--)\r\n          if (1 & (k > 11 ? version >> (k - 12) : t >> k)) {\r\n            qrframe[(5 - x) + width * (2 - y + width - 11)] = 1;\r\n            qrframe[(2 - y + width - 11) + width * (5 - x)] = 1;\r\n          }\r\n          else {\r\n            setmask(5 - x, 2 - y + width - 11);\r\n            setmask(2 - y + width - 11, 5 - x);\r\n          }\r\n    }\r\n\r\n    // sync mask bits - only set above for white spaces, so add in black bits\r\n    for (y = 0; y < width; y++)\r\n      for (x = 0; x <= y; x++)\r\n        if (qrframe[x + width * y])\r\n          setmask(x, y);\r\n\r\n    // convert string to bitstream\r\n    // 8 bit data to QR-coded 8 bit data (numeric or alphanum, or kanji not supported)\r\n    v = strinbuf.length;\r\n\r\n    // string to array\r\n    for (i = 0; i < v; i++)\r\n      eccbuf[i] = strinbuf.charCodeAt(i);\r\n    strinbuf = eccbuf.slice(0);\r\n\r\n    // calculate max string length\r\n    x = datablkw * (neccblk1 + neccblk2) + neccblk2;\r\n    if (v >= x - 2) {\r\n      v = x - 2;\r\n      if (version > 9)\r\n        v--;\r\n    }\r\n\r\n    // shift and repack to insert length prefix\r\n    i = v;\r\n    if (version > 9) {\r\n      strinbuf[i + 2] = 0;\r\n      strinbuf[i + 3] = 0;\r\n      while (i--) {\r\n        t = strinbuf[i];\r\n        strinbuf[i + 3] |= 255 & (t << 4);\r\n        strinbuf[i + 2] = t >> 4;\r\n      }\r\n      strinbuf[2] |= 255 & (v << 4);\r\n      strinbuf[1] = v >> 4;\r\n      strinbuf[0] = 0x40 | (v >> 12);\r\n    }\r\n    else {\r\n      strinbuf[i + 1] = 0;\r\n      strinbuf[i + 2] = 0;\r\n      while (i--) {\r\n        t = strinbuf[i];\r\n        strinbuf[i + 2] |= 255 & (t << 4);\r\n        strinbuf[i + 1] = t >> 4;\r\n      }\r\n      strinbuf[1] |= 255 & (v << 4);\r\n      strinbuf[0] = 0x40 | (v >> 4);\r\n    }\r\n    // fill to end with pad pattern\r\n    i = v + 3 - (version < 10);\r\n    while (i < x) {\r\n      strinbuf[i++] = 0xec;\r\n      // buffer has room    if (i == x)      break;\r\n      strinbuf[i++] = 0x11;\r\n    }\r\n\r\n    // calculate and append ECC\r\n\r\n    // calculate generator polynomial\r\n    genpoly[0] = 1;\r\n    for (i = 0; i < eccblkwid; i++) {\r\n      genpoly[i + 1] = 1;\r\n      for (j = i; j > 0; j--)\r\n        genpoly[j] = genpoly[j]\r\n          ? genpoly[j - 1] ^ gexp[modnn(glog[genpoly[j]] + i)] : genpoly[j - 1];\r\n      genpoly[0] = gexp[modnn(glog[genpoly[0]] + i)];\r\n    }\r\n    for (i = 0; i <= eccblkwid; i++)\r\n      genpoly[i] = glog[genpoly[i]]; // use logs for genpoly[] to save calc step\r\n\r\n    // append ecc to data buffer\r\n    k = x;\r\n    y = 0;\r\n    for (i = 0; i < neccblk1; i++) {\r\n      appendrs(y, datablkw, k, eccblkwid);\r\n      y += datablkw;\r\n      k += eccblkwid;\r\n    }\r\n    for (i = 0; i < neccblk2; i++) {\r\n      appendrs(y, datablkw + 1, k, eccblkwid);\r\n      y += datablkw + 1;\r\n      k += eccblkwid;\r\n    }\r\n    // interleave blocks\r\n    y = 0;\r\n    for (i = 0; i < datablkw; i++) {\r\n      for (j = 0; j < neccblk1; j++)\r\n        eccbuf[y++] = strinbuf[i + j * datablkw];\r\n      for (j = 0; j < neccblk2; j++)\r\n        eccbuf[y++] = strinbuf[(neccblk1 * datablkw) + i + (j * (datablkw + 1))];\r\n    }\r\n    for (j = 0; j < neccblk2; j++)\r\n      eccbuf[y++] = strinbuf[(neccblk1 * datablkw) + i + (j * (datablkw + 1))];\r\n    for (i = 0; i < eccblkwid; i++)\r\n      for (j = 0; j < neccblk1 + neccblk2; j++)\r\n        eccbuf[y++] = strinbuf[x + i + j * eccblkwid];\r\n    strinbuf = eccbuf;\r\n\r\n    // pack bits into frame avoiding masked area.\r\n    x = y = width - 1;\r\n    k = v = 1;         // up, minus\r\n    /* inteleaved data and ecc codes */\r\n    m = (datablkw + eccblkwid) * (neccblk1 + neccblk2) + neccblk2;\r\n    for (i = 0; i < m; i++) {\r\n      t = strinbuf[i];\r\n      for (j = 0; j < 8; j++ , t <<= 1) {\r\n        if (0x80 & t)\r\n          qrframe[x + width * y] = 1;\r\n        do {        // find next fill position\r\n          if (v)\r\n            x--;\r\n          else {\r\n            x++;\r\n            if (k) {\r\n              if (y != 0)\r\n                y--;\r\n              else {\r\n                x -= 2;\r\n                k = !k;\r\n                if (x == 6) {\r\n                  x--;\r\n                  y = 9;\r\n                }\r\n              }\r\n            }\r\n            else {\r\n              if (y != width - 1)\r\n                y++;\r\n              else {\r\n                x -= 2;\r\n                k = !k;\r\n                if (x == 6) {\r\n                  x--;\r\n                  y -= 8;\r\n                }\r\n              }\r\n            }\r\n          }\r\n          v = !v;\r\n        } while (ismasked(x, y));\r\n      }\r\n    }\r\n\r\n    // save pre-mask copy of frame\r\n    strinbuf = qrframe.slice(0);\r\n    t = 0;           // best\r\n    y = 30000;         // demerit\r\n    // for instead of while since in original arduino code\r\n    // if an early mask was \"good enough\" it wouldn't try for a better one\r\n    // since they get more complex and take longer.\r\n    for (k = 0; k < 8; k++) {\r\n      applymask(k);      // returns black-white imbalance\r\n      x = badcheck();\r\n      if (x < y) { // current mask better than previous best?\r\n        y = x;\r\n        t = k;\r\n      }\r\n      if (t == 7)\r\n        break;       // don't increment i to a void redoing mask\r\n      qrframe = strinbuf.slice(0); // reset for next pass\r\n    }\r\n    if (t != k)         // redo best mask - none good enough, last wasn't t\r\n      applymask(t);\r\n\r\n    // add in final mask/ecclevel bytes\r\n    y = fmtword[t + ((ecclevel - 1) << 3)];\r\n    // low byte\r\n    for (k = 0; k < 8; k++ , y >>= 1)\r\n      if (y & 1) {\r\n        qrframe[(width - 1 - k) + width * 8] = 1;\r\n        if (k < 6)\r\n          qrframe[8 + width * k] = 1;\r\n        else\r\n          qrframe[8 + width * (k + 1)] = 1;\r\n      }\r\n    // high byte\r\n    for (k = 0; k < 7; k++ , y >>= 1)\r\n      if (y & 1) {\r\n        qrframe[8 + width * (width - 7 + k)] = 1;\r\n        if (k)\r\n          qrframe[(6 - k) + width * 8] = 1;\r\n        else\r\n          qrframe[7 + width * 8] = 1;\r\n      }\r\n    return qrframe;\r\n  }\r\n\r\n\r\n\r\n\r\n  var _canvas = null;\r\n\r\n  export const api = {\r\n\r\n    get ecclevel() {\r\n      return ecclevel;\r\n    },\r\n\r\n    set ecclevel(val) {\r\n      ecclevel = val;\r\n    },\r\n\r\n    get size() {\r\n      return _size;\r\n    },\r\n\r\n    set size(val) {\r\n      _size = val\r\n    },\r\n\r\n    get canvas() {\r\n      return _canvas;\r\n    },\r\n\r\n    set canvas(el) {\r\n      _canvas = el;\r\n    },\r\n\r\n    getFrame: function (string) {\r\n      return genframe(string);\r\n    },\r\n    //这里的utf16to8(str)是对Text中的字符串进行转码，让其支持中文\r\n    utf16to8: function (str) {\r\n      var out, i, len, c;\r\n\r\n      out = \"\";\r\n      len = str.length;\r\n      for (i = 0; i < len; i++) {\r\n        c = str.charCodeAt(i);\r\n        if ((c >= 0x0001) && (c <= 0x007F)) {\r\n          out += str.charAt(i);\r\n        } else if (c > 0x07FF) {\r\n          out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));\r\n          out += String.fromCharCode(0x80 | ((c >> 6) & 0x3F));\r\n          out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));\r\n        } else {\r\n          out += String.fromCharCode(0xC0 | ((c >> 6) & 0x1F));\r\n          out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));\r\n        }\r\n      }\r\n      return out;\r\n    },\r\n    /**\r\n     * 新增$this参数，传入组件的this,兼容在组件中生成\r\n     * @param bg 目前只能设置颜色值\r\n     */ \r\n    draw: function (str, ctx, startX, startY, cavW, cavH, bg, color, $this, ecc) {\r\n      var that = this;\r\n      ecclevel = ecc || ecclevel;\r\n      if (!ctx) {\r\n        console.warn('No canvas provided to draw QR code in!')\r\n        return;\r\n      }\r\n      var size = Math.min(cavW, cavH);\r\n      str = that.utf16to8(str);//增加中文显示\r\n\r\n      var frame = that.getFrame(str);\r\n      var px = size / width;\r\n      if (bg) {\r\n        ctx.fillStyle = bg\r\n        ctx.fillRect(startX, startY, cavW, cavW);\r\n      }\r\n      ctx.fillStyle = color || 'black'\r\n      for (var i = 0; i < width; i++) {\r\n        for (var j = 0; j < width; j++) {\r\n          if (frame[j * width + i]) {\r\n            ctx.fillRect(startX + px * i, startY + px * j, px, px);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n ","/* eslint-disable */\r\nexport const api = {\r\n  isGradient: function(bg) {\r\n    if (bg && (bg.startsWith('linear') || bg.startsWith('radial'))) {\r\n      return true\r\n    }\r\n    return false\r\n  },\r\n\r\n  doGradient: function(bg, width, height, ctx) {\r\n    if (bg.startsWith('linear')) {\r\n      linearEffect(width, height, bg, ctx)\r\n    } else if (bg.startsWith('radial')) {\r\n      radialEffect(width, height, bg, ctx)\r\n    }\r\n  }\r\n}\r\n\r\nfunction analizeGrad(string) {\r\n  const colorPercents = string.substring(0, string.length - 1).split('%,')\r\n  const colors = []\r\n  const percents = []\r\n  for (let colorPercent of colorPercents) {\r\n    colors.push(colorPercent.substring(0, colorPercent.lastIndexOf(' ')).trim())\r\n    percents.push(colorPercent.substring(colorPercent.lastIndexOf(' '), colorPercent.length) / 100)\r\n  }\r\n  return { colors: colors, percents: percents }\r\n}\r\n\r\nfunction radialEffect(width, height, bg, ctx) {\r\n  const colorPer = analizeGrad(bg.match(/radial-gradient\\((.+)\\)/)[1])\r\n  const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, width < height ? height / 2 : width / 2)\r\n  for (let i = 0; i < colorPer.colors.length; i++) {\r\n    grd.addColorStop(colorPer.percents[i], colorPer.colors[i])\r\n  }\r\n  ctx.fillStyle = grd\r\n  //ctx.fillRect(-(width / 2), -(height / 2), width, height);\r\n}\r\n\r\nfunction analizeLinear(bg, width, height) {\r\n  const direction = bg.match(/([-]?\\d{1,3})deg/)\r\n  const dir = direction && direction[1] ? parseFloat(direction[1]) : 0\r\n  let coordinate\r\n  switch (dir) {\r\n    case 0:\r\n      coordinate = [0, -height / 2, 0, height / 2]\r\n      break\r\n    case 90:\r\n      coordinate = [width / 2, 0, -width / 2, 0]\r\n      break\r\n    case -90:\r\n      coordinate = [-width / 2, 0, width / 2, 0]\r\n      break\r\n    case 180:\r\n      coordinate = [0, height / 2, 0, -height / 2]\r\n      break\r\n    case -180:\r\n      coordinate = [0, -height / 2, 0, height / 2]\r\n      break\r\n    default:\r\n      let x1 = 0\r\n      let y1 = 0\r\n      let x2 = 0\r\n      let y2 = 0\r\n      if (direction[1] > 0 && direction[1] < 90) {\r\n        x1 = width / 2 - (((width / 2) * Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) - height / 2) * Math.sin((2 * (90 - direction[1]) * Math.PI * 2) / 360)) / 2\r\n        y2 = Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) * x1\r\n        x2 = -x1\r\n        y1 = -y2\r\n      } else if (direction[1] > -180 && direction[1] < -90) {\r\n        x1 = -(width / 2) + (((width / 2) * Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) - height / 2) * Math.sin((2 * (90 - direction[1]) * Math.PI * 2) / 360)) / 2\r\n        y2 = Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) * x1\r\n        x2 = -x1\r\n        y1 = -y2\r\n      } else if (direction[1] > 90 && direction[1] < 180) {\r\n        x1 = width / 2 + ((-(width / 2) * Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) - height / 2) * Math.sin((2 * (90 - direction[1]) * Math.PI * 2) / 360)) / 2\r\n        y2 = Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) * x1\r\n        x2 = -x1\r\n        y1 = -y2\r\n      } else {\r\n        x1 = -(width / 2) - ((-(width / 2) * Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) - height / 2) * Math.sin((2 * (90 - direction[1]) * Math.PI * 2) / 360)) / 2\r\n        y2 = Math.tan(((90 - direction[1]) * Math.PI * 2) / 360) * x1\r\n        x2 = -x1\r\n        y1 = -y2\r\n      }\r\n      coordinate = [x1, y1, x2, y2]\r\n      break\r\n  }\r\n  return coordinate\r\n}\r\n\r\nfunction linearEffect(width, height, bg, ctx) {\r\n  const param = analizeLinear(bg, width, height)\r\n  const grd = ctx.createLinearGradient(param[0], param[1], param[2], param[3])\r\n  const content = bg.match(/linear-gradient\\((.+)\\)/)[1]\r\n  const colorPer = analizeGrad(content.substring(content.indexOf(',') + 1))\r\n  for (let i = 0; i < colorPer.colors.length; i++) {\r\n    grd.addColorStop(colorPer.percents[i], colorPer.colors[i])\r\n  }\r\n  ctx.fillStyle = grd\r\n  //ctx.fillRect(-(width / 2), -(height / 2), width, height);\r\n}\r\n","// Exports\nmodule.exports = {\n\n};\n","const QR = require('./qrcode.js')\r\nconst GD = require('./gradient.js')\r\n\r\nexport default class Painter {\r\n  constructor(ctx, data) {\r\n    this.ctx = ctx\r\n    this.data = data\r\n    this.globalWidth = {}\r\n    this.globalHeight = {}\r\n  }\r\n  paint(callback) {\r\n    this.style = {\r\n      width: this.data.width.toPx(),\r\n      height: this.data.height.toPx()\r\n    }\r\n    this._background()\r\n    if (this.data.views && this.data.views.length > 0) {\r\n      for (const view of this.data.views) {\r\n        this._drawAbsolute(view)\r\n      }\r\n    }\r\n    callback && callback()\r\n  }\r\n\r\n  _background() {\r\n    this.ctx.save()\r\n    const { width, height } = this.style\r\n    const bg = this.data.background\r\n    this.ctx.translate(width / 2, height / 2)\r\n    this._doClip(this.data.borderRadius, width, height)\r\n    if (!bg) {\r\n      // 如果未设置背景，则默认使用透明色\r\n      this.ctx.fillStyle = 'transparent'\r\n      this.ctx.fillRect(-(width / 2), -(height / 2), width, height)\r\n    } else if (bg.src) {\r\n      // 背景填充图片\r\n      this.ctx.drawImage(bg, -(width / 2), -(height / 2), width, height)\r\n    }else if (bg.startsWith('#') || bg.startsWith('rgba') || bg.toLowerCase() === 'transparent') {\r\n      // 背景填充颜色\r\n      this.ctx.fillStyle = bg\r\n      this.ctx.fillRect(-(width / 2), -(height / 2), width, height)\r\n    } else if (GD.api.isGradient(bg)) {\r\n      GD.api.doGradient(bg, width, height, this.ctx)\r\n      this.ctx.fillRect(-(width / 2), -(height / 2), width, height)\r\n    }  \r\n    this.ctx.restore()\r\n  }\r\n\r\n  _drawAbsolute(view) {\r\n    if (!(view && view.type)) {\r\n      // 过滤无效 view\r\n      return\r\n    }\r\n    // 证明 css 为数组形式，需要合并\r\n    if (view.css && view.css.length) {\r\n      /* eslint-disable no-param-reassign */\r\n      view.css = Object.assign(...view.css)\r\n    }\r\n    switch (view.type) {\r\n      case 'image':\r\n        this._drawAbsImage(view)\r\n        break\r\n      case 'text':\r\n        this._fillAbsText(view)\r\n        break\r\n      case 'rect':\r\n        this._drawAbsRect(view)\r\n        break\r\n      case 'qrcode':\r\n        this._drawQRCode(view)\r\n        break\r\n      default:\r\n        break\r\n    }\r\n  }\r\n\r\n  _border({ borderRadius = 0, width, height, borderWidth = 0, borderStyle = 'solid' }) {\r\n    let r1 = 0,\r\n      r2 = 0,\r\n      r3 = 0,\r\n      r4 = 0\r\n    const minSize = Math.min(width, height)\r\n    if (borderRadius) {\r\n      const border = borderRadius.split(/\\s+/)\r\n      if (border.length === 4) {\r\n        r1 = Math.min(border[0].toPx(false, minSize), width / 2, height / 2)\r\n        r2 = Math.min(border[1].toPx(false, minSize), width / 2, height / 2)\r\n        r3 = Math.min(border[2].toPx(false, minSize), width / 2, height / 2)\r\n        r4 = Math.min(border[3].toPx(false, minSize), width / 2, height / 2)\r\n      } else {\r\n        r1 = r2 = r3 = r4 = Math.min(borderRadius && borderRadius.toPx(false, minSize), width / 2, height / 2)\r\n      }\r\n    }\r\n    const lineWidth = borderWidth && borderWidth.toPx(false, minSize)\r\n    this.ctx.lineWidth = lineWidth\r\n    if (borderStyle === 'dashed') {\r\n      this.ctx.setLineDash([(lineWidth * 4) / 3, (lineWidth * 4) / 3])\r\n      // this.ctx.lineDashOffset = 2 * lineWidth\r\n    } else if (borderStyle === 'dotted') {\r\n      this.ctx.setLineDash([lineWidth, lineWidth])\r\n    }\r\n    const notSolid = borderStyle !== 'solid'\r\n    this.ctx.beginPath()\r\n\r\n    notSolid && r1 === 0 && this.ctx.moveTo(-width / 2 - lineWidth, -height / 2 - lineWidth / 2) // 顶边虚线规避重叠规则\r\n    r1 !== 0 && this.ctx.arc(-width / 2 + r1, -height / 2 + r1, r1 + lineWidth / 2, 1 * Math.PI, 1.5 * Math.PI) //左上角圆弧\r\n    this.ctx.lineTo(r2 === 0 ? (notSolid ? width / 2 : width / 2 + lineWidth / 2) : width / 2 - r2, -height / 2 - lineWidth / 2) // 顶边线\r\n\r\n    notSolid && r2 === 0 && this.ctx.moveTo(width / 2 + lineWidth / 2, -height / 2 - lineWidth) // 右边虚线规避重叠规则\r\n    r2 !== 0 && this.ctx.arc(width / 2 - r2, -height / 2 + r2, r2 + lineWidth / 2, 1.5 * Math.PI, 2 * Math.PI) // 右上角圆弧\r\n    this.ctx.lineTo(width / 2 + lineWidth / 2, r3 === 0 ? (notSolid ? height / 2 : height / 2 + lineWidth / 2) : height / 2 - r3) // 右边线\r\n\r\n    notSolid && r3 === 0 && this.ctx.moveTo(width / 2 + lineWidth, height / 2 + lineWidth / 2) // 底边虚线规避重叠规则\r\n    r3 !== 0 && this.ctx.arc(width / 2 - r3, height / 2 - r3, r3 + lineWidth / 2, 0, 0.5 * Math.PI) // 右下角圆弧\r\n    this.ctx.lineTo(r4 === 0 ? (notSolid ? -width / 2 : -width / 2 - lineWidth / 2) : -width / 2 + r4, height / 2 + lineWidth / 2) // 底边线\r\n\r\n    notSolid && r4 === 0 && this.ctx.moveTo(-width / 2 - lineWidth / 2, height / 2 + lineWidth) // 左边虚线规避重叠规则\r\n    r4 !== 0 && this.ctx.arc(-width / 2 + r4, height / 2 - r4, r4 + lineWidth / 2, 0.5 * Math.PI, 1 * Math.PI) // 左下角圆弧\r\n    this.ctx.lineTo(-width / 2 - lineWidth / 2, r1 === 0 ? (notSolid ? -height / 2 : -height / 2 - lineWidth / 2) : -height / 2 + r1) // 左边线\r\n    notSolid && r1 === 0 && this.ctx.moveTo(-width / 2 - lineWidth, -height / 2 - lineWidth / 2) // 顶边虚线规避重叠规则\r\n\r\n    if (!notSolid) {\r\n      this.ctx.closePath()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 根据 borderRadius 进行裁减\r\n   */\r\n  _doClip(borderRadius, width, height, borderStyle) {\r\n    if (borderRadius && width && height) {\r\n      // 防止在某些机型上周边有黑框现象，此处如果直接设置 fillStyle 为透明，在 Android 机型上会导致被裁减的图片也变为透明， iOS 和 IDE 上不会\r\n      // globalAlpha 在 1.9.90 起支持，低版本下无效，但把 fillStyle 设为了 white，相对默认的 black 要好点\r\n      this.ctx.globalAlpha = 0\r\n      this.ctx.fillStyle = 'white'\r\n      this._border({\r\n        borderRadius,\r\n        width,\r\n        height,\r\n        borderStyle\r\n      })\r\n      this.ctx.fill()\r\n      // 在 ios 的 6.6.6 版本上 clip 有 bug，禁掉此类型上的 clip，也就意味着，在此版本微信的 ios 设备下无法使用 border 属性\r\n      this.ctx.clip()\r\n      this.ctx.globalAlpha = 1\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 画边框\r\n   */\r\n  _doBorder(view, width, height) {\r\n    if (!view.css) {\r\n      return\r\n    }\r\n    const { borderRadius, borderWidth, borderColor, borderStyle } = view.css\r\n    if (!borderWidth) {\r\n      return\r\n    }\r\n    this.ctx.save()\r\n    this._preProcess(view, true)\r\n    this.ctx.strokeStyle = borderColor || 'black'\r\n    this._border({\r\n      borderRadius,\r\n      width,\r\n      height,\r\n      borderWidth,\r\n      borderStyle\r\n    })\r\n    this.ctx.stroke()\r\n    this.ctx.restore()\r\n  }\r\n\r\n  _preProcess(view, notClip) {\r\n    let width = 0\r\n    let height\r\n    let extra\r\n    const paddings = this._doPaddings(view)\r\n    switch (view.type) {\r\n      case 'text': {\r\n        const textArray = view.text.split('\\n')\r\n        // 处理多个连续的'\\n'\r\n        for (let i = 0; i < textArray.length; ++i) {\r\n          if (textArray[i] === '') {\r\n            textArray[i] = ' '\r\n          }\r\n        }\r\n        // const fontWeight = view.css.fontWeight === 'bold' ? 'bold' : 'normal'\r\n        const fontWeightArr = ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '700', '800', '900']\r\n        const fontWeight = fontWeightArr.includes(view.css.fontWeight) ? view.css.fontWeight : 'normal'\r\n        const textStyle = view.css.textStyle === 'italic' ? 'italic' : 'normal'\r\n        let textIndent = view.css.textIndent ? view.css.textIndent.toPx() : 0\r\n\r\n        if (!view.css.fontSize) {\r\n          view.css.fontSize = '20rpx'\r\n        }\r\n        this.ctx.font = `${textStyle} ${fontWeight} ${view.css.fontSize.toPx()}px \"${view.css.fontFamily || 'sans-serif'}\"`\r\n        // 计算行数\r\n        let lines = 0\r\n        const linesArray = []\r\n        for (let i = 0; i < textArray.length; ++i) {\r\n          const textLength = this.ctx.measureText(textArray[i]).width\r\n          // 最小长度\r\n          const minWidth = view.css.fontSize.toPx() + paddings[1] + paddings[3]\r\n          let partWidth = view.css.width ? view.css.width.toPx(false, this.style.width) - paddings[1] - paddings[3] : textLength\r\n\r\n          if (partWidth < minWidth) {\r\n            partWidth = minWidth\r\n          }\r\n          // textIndent 最大为一行\r\n          textIndent = textIndent > partWidth ? partWidth : textIndent\r\n          const calLines = Math.ceil((textLength + textIndent) / partWidth)\r\n          // 取最长的作为 width\r\n          width = partWidth > width ? partWidth : width\r\n          lines += calLines\r\n          linesArray[i] = calLines\r\n        }\r\n        lines = view.css.maxLines < lines ? view.css.maxLines : lines\r\n        const lineHeight = view.css.lineHeight ? view.css.lineHeight.toPx() : view.css.fontSize.toPx()\r\n        height = lineHeight * lines\r\n        extra = {\r\n          textIndent,\r\n          lines: lines,\r\n          lineHeight: lineHeight,\r\n          textArray: textArray,\r\n          linesArray: linesArray\r\n        }\r\n        break\r\n      }\r\n      case 'image': {\r\n        // 有css却未设置width或height，则默认为auto\r\n        if (view.css) {\r\n          if (!view.css.width) {\r\n            view.css.width = 'auto'\r\n          }\r\n          if (!view.css.height) {\r\n            view.css.height = 'auto'\r\n          }\r\n        }\r\n        if (!view.css || (view.css.width === 'auto' && view.css.height === 'auto')) {\r\n          width = Math.round(view.sWidth)\r\n          height = Math.round(view.sHeight)\r\n        } else if (view.css.width === 'auto') {\r\n          height = view.css.height.toPx(false, this.style.height)\r\n          width = (view.sWidth / view.sHeight) * height\r\n        } else if (view.css.height === 'auto') {\r\n          width = view.css.width.toPx(false, this.style.width)\r\n          height = (view.sHeight / view.sWidth) * width\r\n        } else {\r\n          width = view.css.width.toPx(false, this.style.width)\r\n          height = view.css.height.toPx(false, this.style.height)\r\n        }\r\n        break\r\n      }\r\n      default:\r\n        if (!(view.css.width && view.css.height)) {\r\n          console.error('You should set width and height')\r\n          return\r\n        }\r\n        width = view.css.width.toPx(false, this.style.width)\r\n        height = view.css.height.toPx(false, this.style.height)\r\n        break\r\n    }\r\n    let x\r\n    if (view.css && view.css.right) {\r\n      if (typeof view.css.right === 'string') {\r\n        x = this.style.width - view.css.right.toPx(true, this.style.width)\r\n      } else {\r\n        // 可以用数组方式，把文字长度计算进去\r\n        // [right, 文字id, 乘数（默认 1）]\r\n        const rights = view.css.right\r\n        x = this.style.width - rights[0].toPx(true, this.style.width) - this.globalWidth[rights[1]] * (rights[2] || 1)\r\n      }\r\n    } else if (view.css && view.css.left) {\r\n      if (typeof view.css.left === 'string') {\r\n        x = view.css.left.toPx(true, this.style.width)\r\n      } else {\r\n        const lefts = view.css.left\r\n        x = lefts[0].toPx(true, this.style.width) + this.globalWidth[lefts[1]] * (lefts[2] || 1)\r\n      }\r\n    } else {\r\n      x = 0\r\n    }\r\n    //const y = view.css && view.css.bottom ? this.style.height - height - view.css.bottom.toPx(true) : (view.css && view.css.top ? view.css.top.toPx(true) : 0);\r\n    let y\r\n    if (view.css && view.css.bottom) {\r\n      y = this.style.height - height - view.css.bottom.toPx(true, this.style.height)\r\n    } else {\r\n      if (view.css && view.css.top) {\r\n        if (typeof view.css.top === 'string') {\r\n          y = view.css.top.toPx(true, this.style.height)\r\n        } else {\r\n          const tops = view.css.top\r\n          y = tops[0].toPx(true, this.style.height) + this.globalHeight[tops[1]] * (tops[2] || 1)\r\n        }\r\n      } else {\r\n        y = 0\r\n      }\r\n    }\r\n\r\n    const angle = view.css && view.css.rotate ? this._getAngle(view.css.rotate) : 0\r\n    // 当设置了 right 时，默认 align 用 right，反之用 left\r\n    const align = view.css && view.css.align ? view.css.align : view.css && view.css.right ? 'right' : 'left'\r\n    const verticalAlign = view.css && view.css.verticalAlign ? view.css.verticalAlign : 'top'\r\n    // 记录绘制时的画布\r\n    let xa = 0\r\n    switch (align) {\r\n      case 'center':\r\n        xa = x\r\n        break\r\n      case 'right':\r\n        xa = x - width / 2\r\n        break\r\n      default:\r\n        xa = x + width / 2\r\n        break\r\n    }\r\n    let ya = 0\r\n    switch (verticalAlign) {\r\n      case 'center':\r\n        ya = y\r\n        break\r\n      case 'bottom':\r\n        ya = y - height / 2\r\n        break\r\n      default:\r\n        ya = y + height / 2\r\n        break\r\n    }\r\n    this.ctx.translate(xa, ya)\r\n    // 记录该 view 的有效点击区域\r\n    // TODO ，旋转和裁剪的判断\r\n    // 记录在真实画布上的左侧\r\n    let left = x\r\n    if (align === 'center') {\r\n      left = x - width / 2\r\n    } else if (align === 'right') {\r\n      left = x - width\r\n    }\r\n    var top = y\r\n    if (verticalAlign === 'center') {\r\n      top = y - height / 2\r\n    } else if (verticalAlign === 'bottom') {\r\n      top = y - height\r\n    }\r\n    if (view.rect) {\r\n      view.rect.left = left\r\n      view.rect.top = top\r\n      view.rect.right = left + width\r\n      view.rect.bottom = top + height\r\n      view.rect.x = view.css && view.css.right ? x - width : x\r\n      view.rect.y = y\r\n    } else {\r\n      view.rect = {\r\n        left: left,\r\n        top: top,\r\n        right: left + width,\r\n        bottom: top + height,\r\n        x: view.css && view.css.right ? x - width : x,\r\n        y: y\r\n      }\r\n    }\r\n\r\n    view.rect.left = view.rect.left - paddings[3]\r\n    view.rect.top = view.rect.top - paddings[0]\r\n    view.rect.right = view.rect.right + paddings[1]\r\n    view.rect.bottom = view.rect.bottom + paddings[2]\r\n    if (view.type === 'text') {\r\n      view.rect.minWidth = view.css.fontSize.toPx() + paddings[1] + paddings[3]\r\n    }\r\n\r\n    this.ctx.rotate(angle)\r\n    if (!notClip && view.css && view.css.borderRadius && view.type !== 'rect') {\r\n      this._doClip(view.css.borderRadius, width, height, view.css.borderStyle)\r\n    }\r\n    this._doShadow(view)\r\n    if (view.id) {\r\n      this.globalWidth[view.id] = width\r\n      this.globalHeight[view.id] = height\r\n    }\r\n    return {\r\n      width: width,\r\n      height: height,\r\n      x: x,\r\n      y: y,\r\n      extra: extra\r\n    }\r\n  }\r\n\r\n  _doPaddings(view) {\r\n    const { padding } = view.css ? view.css : {}\r\n    let pd = [0, 0, 0, 0]\r\n    if (padding) {\r\n      const pdg = padding.split(/\\s+/)\r\n      if (pdg.length === 1) {\r\n        const x = pdg[0].toPx()\r\n        pd = [x, x, x, x]\r\n      }\r\n      if (pdg.length === 2) {\r\n        const x = pdg[0].toPx()\r\n        const y = pdg[1].toPx()\r\n        pd = [x, y, x, y]\r\n      }\r\n      if (pdg.length === 3) {\r\n        const x = pdg[0].toPx()\r\n        const y = pdg[1].toPx()\r\n        const z = pdg[2].toPx()\r\n        pd = [x, y, z, y]\r\n      }\r\n      if (pdg.length === 4) {\r\n        const x = pdg[0].toPx()\r\n        const y = pdg[1].toPx()\r\n        const z = pdg[2].toPx()\r\n        const a = pdg[3].toPx()\r\n        pd = [x, y, z, a]\r\n      }\r\n    }\r\n    return pd\r\n  }\r\n\r\n  // 画文字的背景图片\r\n  _doBackground(view) {\r\n    this.ctx.save()\r\n    const { width: rawWidth, height: rawHeight } = this._preProcess(view, true)\r\n    const { background } = view.css\r\n    let pd = this._doPaddings(view)\r\n    const width = rawWidth + pd[1] + pd[3]\r\n    const height = rawHeight + pd[0] + pd[2]\r\n    this._doClip(view.css.borderRadius, width, height, view.css.borderStyle)\r\n    if (GD.api.isGradient(background)) {\r\n      GD.api.doGradient(background, width, height, this.ctx)\r\n    } else {\r\n      this.ctx.fillStyle = background\r\n    }\r\n    this.ctx.fillRect(-(width / 2), -(height / 2), width, height)\r\n\r\n    this.ctx.restore()\r\n  }\r\n\r\n  _drawQRCode(view) {\r\n    this.ctx.save()\r\n    const { width, height } = this._preProcess(view)\r\n    QR.api.draw(view.content, this.ctx, -width / 2, -height / 2, width, height, view.css.background, view.css.color)\r\n    this.ctx.restore()\r\n    this._doBorder(view, width, height)\r\n  }\r\n\r\n  _drawAbsImage(view) {\r\n    if (!view.url) {\r\n      return\r\n    }\r\n    this.ctx.save()\r\n    const { width, height } = this._preProcess(view)\r\n    // 图片失败\r\n    if (typeof view.url === 'string') {\r\n      this.ctx.fillStyle = '#ddd'\r\n      this.ctx.fillRect(-(width / 2), -(height / 2), width, height)\r\n      this.ctx.restore()\r\n      return\r\n    }\r\n    // 获得缩放到图片大小级别的裁减框\r\n    let rWidth = view.sWidth\r\n    let rHeight = view.sHeight\r\n    let startX = 0\r\n    let startY = 0\r\n    // 绘画区域比例\r\n    const cp = width / height\r\n    // 原图比例\r\n    const op = view.sWidth / view.sHeight\r\n    if (cp >= op) {\r\n      rHeight = rWidth / cp\r\n      startY = Math.round((view.sHeight - rHeight) / 2)\r\n    } else {\r\n      rWidth = rHeight * cp\r\n      startX = Math.round((view.sWidth - rWidth) / 2)\r\n    }\r\n    if (view.css && view.css.mode === 'scaleToFill') {\r\n      this.ctx.drawImage(view.url, -(width / 2), -(height / 2), width, height)\r\n    } else {\r\n      this.ctx.drawImage(view.url, startX, startY, rWidth, rHeight, -(width / 2), -(height / 2), width, height)\r\n      view.rect.startX = startX / view.sWidth\r\n      view.rect.startY = startY / view.sHeight\r\n      view.rect.endX = (startX + rWidth) / view.sWidth\r\n      view.rect.endY = (startY + rHeight) / view.sHeight\r\n    }\r\n    this.ctx.restore()\r\n    this._doBorder(view, width, height)\r\n  }\r\n\r\n  _fillAbsText(view) {\r\n    if (!view.text) {\r\n      return\r\n    }\r\n    if (view.css.background) {\r\n      // 生成背景\r\n      this._doBackground(view)\r\n    }\r\n    this.ctx.save()\r\n    const { width, height, extra } = this._preProcess(view, view.css.background && view.css.borderRadius)\r\n    this.ctx.fillStyle = view.css.color || 'black'\r\n    const { lines, lineHeight, textArray, linesArray, textIndent } = extra\r\n    // 如果设置了id，则保留 text 的长度\r\n    if (view.id) {\r\n      let textWidth = 0\r\n      for (let i = 0; i < textArray.length; ++i) {\r\n        const _w = this.ctx.measureText(textArray[i]).width\r\n        textWidth = _w > textWidth ? _w : textWidth\r\n      }\r\n      this.globalWidth[view.id] = width ? (textWidth < width ? textWidth : width) : textWidth\r\n    }\r\n    let lineIndex = 0\r\n    let tabWidth = 0\r\n    for (let j = 0; j < textArray.length; ++j) {\r\n      const preLineLength = Math.ceil(textArray[j].length / linesArray[j])\r\n      const firstLineLength = Math.ceil(((width - textIndent) / width) * (textArray[j].length / linesArray[j]))\r\n      let start = 0\r\n      let alreadyCount = 0\r\n\r\n      for (let i = 0; i < linesArray[j]; ++i) {\r\n        // 绘制行数大于最大行数，则直接跳出循环\r\n        if (lineIndex >= lines) {\r\n          break\r\n        }\r\n        tabWidth = i == 0 ? textIndent : 0\r\n        alreadyCount = i == 0 ? firstLineLength : preLineLength\r\n        let text = textArray[j].substr(start, alreadyCount)\r\n        let measuredWith = this.ctx.measureText(text).width\r\n        // 如果测量大小小于width一个字符的大小，则进行补齐，如果测量大小超出 width，则进行减除\r\n        // 如果已经到文本末尾，也不要进行该循环\r\n        while (start + alreadyCount <= textArray[j].length && (width - measuredWith - tabWidth > view.css.fontSize.toPx() || measuredWith - width > view.css.fontSize.toPx())) {\r\n          if (measuredWith < width) {\r\n            text = textArray[j].substr(start, ++alreadyCount)\r\n          } else {\r\n            if (text.length <= 1) {\r\n              // 如果只有一个字符时，直接跳出循环\r\n              break\r\n            }\r\n            text = textArray[j].substr(start, --alreadyCount)\r\n            // break\r\n          }\r\n          measuredWith = this.ctx.measureText(text).width\r\n        }\r\n        start += text.length\r\n        // 如果是最后一行了，发现还有未绘制完的内容，则加...\r\n        if (lineIndex === lines - 1 && (j < textArray.length - 1 || start < textArray[j].length)) {\r\n          while (this.ctx.measureText(`${text}...`).width > width) {\r\n            if (text.length <= 1) {\r\n              // 如果只有一个字符时，直接跳出循环\r\n              break\r\n            }\r\n            text = text.substring(0, text.length - 1)\r\n          }\r\n          text += '...'\r\n          measuredWith = this.ctx.measureText(text).width\r\n        }\r\n        this.ctx.textAlign = view.css.textAlign ? view.css.textAlign : 'left'\r\n        let x\r\n        let lineX\r\n        switch (view.css.textAlign) {\r\n          case 'center':\r\n            x = 0\r\n            lineX = x - measuredWith / 2 + tabWidth\r\n            break\r\n          case 'right':\r\n            x = width / 2\r\n            lineX = x - measuredWith + tabWidth\r\n            break\r\n          default:\r\n            x = -(width / 2) + tabWidth\r\n            lineX = x\r\n            break\r\n        }\r\n        const y = -(height / 2) + (lineIndex === 0 ? view.css.fontSize.toPx() : view.css.fontSize.toPx() + lineIndex * lineHeight)\r\n        lineIndex++\r\n        if (view.css.textStyle === 'stroke') {\r\n          this.ctx.strokeText(text, x, y, measuredWith)\r\n        } else {\r\n          this.ctx.fillText(text, x, y, measuredWith)\r\n        }\r\n        const fontSize = view.css.fontSize.toPx()\r\n        if (view.css.textDecoration) {\r\n          this.ctx.lineWidth = fontSize / 13\r\n          this.ctx.beginPath()\r\n          if (/\\bunderline\\b/.test(view.css.textDecoration)) {\r\n            this.ctx.moveTo(lineX, y)\r\n            this.ctx.lineTo(lineX + measuredWith, y)\r\n          }\r\n          if (/\\boverline\\b/.test(view.css.textDecoration)) {\r\n            this.ctx.moveTo(lineX, y - fontSize)\r\n            this.ctx.lineTo(lineX + measuredWith, y - fontSize)\r\n          }\r\n          if (/\\bline-through\\b/.test(view.css.textDecoration)) {\r\n            this.ctx.moveTo(lineX, y - fontSize / 3)\r\n            this.ctx.lineTo(lineX + measuredWith, y - fontSize / 3)\r\n          }\r\n          this.ctx.closePath()\r\n          this.ctx.strokeStyle = view.css.color\r\n          this.ctx.stroke()\r\n        }\r\n      }\r\n    }\r\n    this.ctx.restore()\r\n    this._doBorder(view, width, height)\r\n  }\r\n\r\n  _drawAbsRect(view) {\r\n    this.ctx.save()\r\n    const { width, height } = this._preProcess(view)\r\n    if (GD.api.isGradient(view.css.color)) {\r\n      GD.api.doGradient(view.css.color, width, height, this.ctx)\r\n    } else {\r\n      this.ctx.fillStyle = view.css.color\r\n    }\r\n    const { borderRadius, borderStyle, borderWidth } = view.css\r\n    this._border({\r\n      borderRadius,\r\n      width,\r\n      height,\r\n      borderWidth,\r\n      borderStyle\r\n    })\r\n    this.ctx.fill()\r\n    this.ctx.restore()\r\n    this._doBorder(view, width, height)\r\n  }\r\n\r\n  // shadow 支持 (x, y, blur, color), 不支持 spread\r\n  // shadow:0px 0px 10px rgba(0,0,0,0.1);\r\n  _doShadow(view) {\r\n    if (!view.css || !view.css.shadow) {\r\n      return\r\n    }\r\n    const box = view.css.shadow.replace(/,\\s+/g, ',').split(/\\s+/)\r\n    if (box.length > 4) {\r\n      console.error(\"shadow don't spread option\")\r\n      return\r\n    }\r\n    this.ctx.shadowOffsetX = parseInt(box[0], 10)\r\n    this.ctx.shadowOffsetY = parseInt(box[1], 10)\r\n    this.ctx.shadowBlur = parseInt(box[2], 10)\r\n    this.ctx.shadowColor = box[3]\r\n  }\r\n\r\n  _getAngle(angle) {\r\n    return (Number(angle) * Math.PI) / 180\r\n  }\r\n}\r\n","const isValidUrl = url => {\r\n  return /(ht|f)tp(s?):\\/\\/([^ \\\\/]*\\.)+[^ \\\\/]*(:[0-9]+)?\\/?/.test(url)\r\n}\r\n\r\n/**\r\n * 深度对比两个对象是否一致\r\n * from: https://github.com/epoberezkin/fast-deep-equal\r\n * @param  {Object} a 对象a\r\n * @param  {Object} b 对象b\r\n * @return {Boolean}   是否相同\r\n */\r\n/* eslint-disable */\r\nconst equal = (a, b) => {\r\n  if (a === b) return true\r\n\r\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\r\n    var arrA = Array.isArray(a),\r\n      arrB = Array.isArray(b),\r\n      i,\r\n      length,\r\n      key\r\n\r\n    if (arrA && arrB) {\r\n      length = a.length\r\n      if (length != b.length) return false\r\n      for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false\r\n      return true\r\n    }\r\n\r\n    if (arrA != arrB) return false\r\n\r\n    var dateA = a instanceof Date,\r\n      dateB = b instanceof Date\r\n    if (dateA != dateB) return false\r\n    if (dateA && dateB) return a.getTime() == b.getTime()\r\n\r\n    var regexpA = a instanceof RegExp,\r\n      regexpB = b instanceof RegExp\r\n    if (regexpA != regexpB) return false\r\n    if (regexpA && regexpB) return a.toString() == b.toString()\r\n\r\n    var keys = Object.keys(a)\r\n    length = keys.length\r\n\r\n    if (length !== Object.keys(b).length) return false\r\n\r\n    for (i = length; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\r\n\r\n    for (i = length; i-- !== 0; ) {\r\n      key = keys[i]\r\n      if (!equal(a[key], b[key])) return false\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  return a !== a && b !== b\r\n}\r\n\r\nexport { isValidUrl, equal }\r\n","export * from \"-!../../../node_modules/css-loader/dist/cjs.js??ref--3-oneOf-1-0!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--3-oneOf-1-1!../../../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./canvas-poster.vue?vue&type=style&index=0&id=b137f4e8&scoped=true&lang=css&\"","\r\nimport Painter from './painter'\r\nimport { equal } from './util'\r\nexport default {\r\n  name: 'VueCanvasPoster',\r\n  props: {\r\n    painting: {\r\n      type: Object,\r\n      default: function() {\r\n        return {}\r\n      }\r\n    },\r\n    dirty: {\r\n      type: Boolean,\r\n      default: false\r\n    },\r\n    widthPixels: {\r\n      type: Number,\r\n      default: 750\r\n    }\r\n  },\r\n  watch: {\r\n    painting: {\r\n      handler(newVal, oldVal) {\r\n        if (this.isNeedRefresh(newVal, oldVal)) {\r\n          this.paintCount = 0\r\n          this.startPaint()\r\n        }\r\n      },\r\n      deep: true,\r\n      immediate: true\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      paintCount: 0,\r\n      painterStyle: '',\r\n      canvasWidthInPx: 375,\r\n      canvasHeightInPx: 375,\r\n      width: 100,\r\n      height: 100,\r\n      canvas: null,\r\n      ctx: null\r\n    }\r\n  },\r\n  render(h) {\r\n    return h('div', [\r\n      h('canvas', {\r\n        ref: 'canvas',\r\n        class: 'canvas',\r\n        style: this.painterStyle\r\n      })\r\n    ])\r\n  },\r\n  mounted() {\r\n    this.$nextTick(() => {\r\n      this.canvas = this.$refs.canvas // 指定canvas\r\n      this.ctx = this.canvas.getContext('2d') //设置2D渲染区域\r\n    })\r\n  },\r\n  methods: {\r\n    /**\r\n     * 判断一个 object 是否为 空\r\n     * @param {object} object\r\n     */\r\n    isEmpty(object) {\r\n      for (const i in object) {\r\n        return false\r\n      }\r\n      return true\r\n    },\r\n    isNeedRefresh(newVal, oldVal) {\r\n      if (!newVal || this.isEmpty(newVal) || (this.dirty && equal(newVal, oldVal))) {\r\n        return false\r\n      }\r\n      return true\r\n    },\r\n    // 开始绘画\r\n    startPaint() {\r\n      if (this.isEmpty(this.painting)) {\r\n        return\r\n      }\r\n      setStringPrototype(1)\r\n      // 下载图片\r\n      this.downloadImages()\r\n        .then(res => {\r\n          const { width, height } = res\r\n          if (!width || !height) {\r\n            console.error(`You should set width and height correctly for painter, width: ${width}, height: ${height}`)\r\n            return\r\n          }\r\n          this.canvasWidthInPx = width.toPx()\r\n          if (this.widthPixels) {\r\n            // 重设宽度，高度\r\n            setStringPrototype(this.widthPixels / this.canvasWidthInPx)\r\n            this.canvasWidthInPx = this.widthPixels\r\n          }\r\n          this.canvasHeightInPx = height.toPx()\r\n          this.painterStyle = `width:${this.canvasWidthInPx}px;height:${this.canvasHeightInPx}px;`\r\n          this.canvas = this.$refs.canvas // 指定canvas\r\n          this.canvas.width = this.canvasWidthInPx\r\n          this.canvas.height = this.canvasHeightInPx\r\n          const ctx = this.canvas.getContext('2d') //设置2D渲染区域\r\n          const pen = new Painter(ctx, res)\r\n          pen.paint(() => {\r\n            var imageBase64 = this.canvas.toDataURL('image/png')\r\n            this.$emit('success', imageBase64)\r\n          })\r\n        })\r\n        .catch(err => {\r\n          this.$emit('fail', err)\r\n        })\r\n    },\r\n    // 下载所有图片\r\n    downloadImages() {\r\n      return new Promise((resolve) => {\r\n        let preCount = 0\r\n        let completeCount = 0\r\n        const paintCopy = JSON.parse(JSON.stringify(this.painting))\r\n        if (paintCopy.background) {\r\n          preCount++\r\n          this.loadImage(paintCopy.background).then(\r\n            image => {\r\n              paintCopy.background = image\r\n              completeCount++\r\n              preCount === completeCount && resolve(paintCopy)\r\n            },\r\n            err => {\r\n              completeCount++\r\n              preCount === completeCount && resolve(paintCopy)\r\n              console.log(err)\r\n            }\r\n          )\r\n        }\r\n        if (paintCopy.views) {\r\n          for (const view of paintCopy.views) {\r\n            if (view && view.type === 'image' && view.url) {\r\n              preCount++\r\n              /* eslint-disable no-loop-func */\r\n              this.loadImage(view.url).then(\r\n                image => {\r\n                  completeCount++\r\n                  view.url = image\r\n                  // 获得一下图片信息，供后续裁减使用\r\n                  view.sWidth = image.width\r\n                  view.sHeight = image.height\r\n                  preCount === completeCount && resolve(paintCopy)\r\n                },\r\n                err => {\r\n                  completeCount++\r\n                  preCount === completeCount && resolve(paintCopy)\r\n                  console.log(err)\r\n                }\r\n              )\r\n            }\r\n          }\r\n        }\r\n        preCount === 0 && resolve(paintCopy)\r\n        // if (preCount !== completeCount) {\r\n        //   reject('paintCopy');\r\n        // }\r\n      })\r\n    },\r\n    // 下载图片\r\n    loadImage(src) {\r\n      return new Promise((resolve, reject) => {\r\n        if (src.startsWith('#')) {\r\n          resolve(src)\r\n          return\r\n        }\r\n        const img = new Image()\r\n        img.onload = () => resolve(img)\r\n        img.onerror = () => reject(`下载图片失败 ${src}`)\r\n        img.crossOrigin = 'anonymous'\r\n        img.src = src\r\n        if (img.complete === true) {\r\n          // Inline XML images may fail to parse, throwing an Error later on\r\n          setTimeout(() => resolve(img), 500)\r\n        }\r\n      })\r\n    }\r\n  }\r\n}\r\nfunction setStringPrototype(scale) {\r\n  /* eslint-disable no-extend-native */\r\n  /**\r\n   * 是否支持负数\r\n   * @param {Boolean} minus 是否支持负数\r\n   */\r\n  String.prototype.toPx = function toPx(minus, baseSize) {\r\n    if (this === '0') {\r\n      return 0\r\n    }\r\n    let reg\r\n    if (minus) {\r\n      reg = /^-?[0-9]+([.]{1}[0-9]+){0,1}(px|%)$/g\r\n    } else {\r\n      reg = /^[0-9]+([.]{1}[0-9]+){0,1}(px|%)$/g\r\n    }\r\n    const results = reg.exec(this)\r\n    const unit = results[2]\r\n    const value = parseFloat(this)\r\n    let res = 0\r\n    if (unit === 'px') {\r\n      res = Math.round(value * (scale || 1))\r\n    } else if (unit === '%') {\r\n      res = Math.round((value * baseSize) / 100)\r\n    }\r\n    return res\r\n  }\r\n}\r\n","import mod from \"-!../../../node_modules/babel-loader/lib/index.js??ref--2-0!../../../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./canvas-poster.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/babel-loader/lib/index.js??ref--2-0!../../../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./canvas-poster.vue?vue&type=script&lang=js&\"","var render, staticRenderFns\nimport script from \"./canvas-poster.vue?vue&type=script&lang=js&\"\nexport * from \"./canvas-poster.vue?vue&type=script&lang=js&\"\nfunction injectStyles (context) {\n  \n  var style0 = require(\"./canvas-poster.vue?vue&type=style&index=0&id=b137f4e8&scoped=true&lang=css&\")\nif (style0.__inject__) style0.__inject__(context)\n\n}\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  injectStyles,\n  \"b137f4e8\",\n  \"2871282e\"\n  \n)\n\nexport default component.exports","import VueCanvasPoster from './canvas-poster'\r\n\r\nexport function install(Vue) {\r\n  Vue.component('vue-canvas-poster', VueCanvasPoster)\r\n}\r\nexport { VueCanvasPoster }\r\nconst myPlugin = {\r\n  install\r\n}\r\nexport default myPlugin\r\n// Auto-install\r\nlet GlobalVue = null\r\nif (typeof window !== 'undefined') {\r\n  GlobalVue = window.Vue\r\n} else if (typeof global !== 'undefined') {\r\n  GlobalVue = global.Vue\r\n}\r\nif (GlobalVue) {\r\n  GlobalVue.use(myPlugin)\r\n}\r\n"],"mappings":";;;;;;;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAMA;AACA;AAQA;AAEA;AACA;AACA;AAJA;AACA;AAOA;AACA;AA2CA;AACA;AAmBA;AAoBA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAGA;AAEA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAEA;AAEA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAhFA;AACA;AAiFA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAKA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AADA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AAIA;AACA;AAAA;AACA;AACA;AAIA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9EA;;;;;;;;AC3rBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AACA;AAgBA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AA3CA;AACA;AA4CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;;;;;;;ACrGA;AACA;AACA;AACA;;;;;;;;;ACHA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAdA;AAgBA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAJA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAnFA;AACA;AAoFA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AATA;AACA;AAUA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AATA;AACA;AAUA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAZA;AACA;AAaA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAMA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnoBA;;;;;;;;ACHA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1DA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;ACCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAXA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AARA;AADA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAzHA;AAzDA;AACA;AAmLA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;AClNA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;A","sourceRoot":""}